" How many lines of history VIM has to remember
set history=100

" All of plugins must be added here, before 'filetype plugin indent'
if isdirectory(expand('~/.vim/bundle/Vundle.vim'))
    set rtp+=~/.vim/bundle/Vundle.vim
    call vundle#begin()

    " let Vundle manage Vundle, required
    Plugin 'VundleVim/Vundle.vim'

    Plugin 'Valloric/YouCompleteMe'
    Plugin 'preservim/nerdtree'
    Plugin 'ctrlpvim/ctrlp.vim'

    call vundle#end()
endif

"==================== INSTALL GVIM (vim-gtk3) TO ENABLE CLIPBOARD FEATURES ====================

" Filetype plugins
filetype plugin on
filetype indent on

" Set to auto read when a file is changed from outside
set autoread
au FocusGained,BufEnter * checktime

" Graphical menu for autocomplete
set wildmenu

" Make 'find' fuzzy
" Search down into subfolders
" Provides tab completion for all file related tasks
set path+=**

" Always show cursor position
set ruler

" Configure backspace to work properly in INSERT mode
set backspace=eol,start,indent
set whichwrap+=<,>,h,l

" Highlight search results
set hlsearch
set incsearch

" Ignores case during search
set ignorecase
set smartcase

" Enable syntax highlighting
syntax enable

" Use solarized color scheme
colorscheme badwolf

" Use spaces for tabs
set expandtab

" TAB = 4 spaces
set tabstop=4
set shiftwidth=4
set softtabstop=4

" Set an hybrid of absolute and relative numbers
set number relativenumber

" Highlight matching
set showmatch

" Shows the last command in the bottom right
set showcmd

" Draws a horizontal highlight on the line the cursor is currently on
set cursorline

" Set vertical split to open new window on the right
set splitright

" Smart way to move between windows
map <C-j> <C-W>j
map <C-k> <C-W>k
map <C-h> <C-W>h
map <C-l> <C-W>l

" With a map1leader it's possible to do extra key combinations
" like <leader>w saves the current file
let mapleader=","

" Map <leader><space> to clear search highlight
nnoremap <leader><space> :nohlsearch<CR>

" Map <leader>ss to toggle and untoggle spell checking
map <leader>ss :setlocal spell!<CR>

" Map <leader>t to open a new tab
map <leader>t :tabnew<CR>

" Map <leader>g to perform vimgrep recursively
map <leader>g :vimgrep //gj **/*<left><left><left><left><left><left><left><left>

" Map <leader>G  to perform vimgrep recursively only on git worktree
map <leader>G :vimgrep //gj `git ls-files`<left><left><left><left><left><left><left><left><left><left><left><left><left><left><left><left><left><left>

" Map <leader>f to perform 'fuzzy search like' on edit command
map <leader>f :edit  **/*

" Map <leader>b to list buffers
map <leader>b :ls<CR>

" Map <leader>/ to perform a 'comment block' command (using //)
map <leader>/ :normal 0i//<CR>

" Map <leader># to perform a 'comment block' command (using #)
map <leader># :normal 0i#<CR>

" Map <leader>. to remove all trailing spaces
map <leader>. :%s/\s\+$//g<CR>

" Map <leader>; to Highlight trailing spaces
map <leader>; :/\s\+$<CR>

" YouCompleteMe Jump To Definition
nnoremap <leader>jd :YcmCompleter GoTo<CR>
nnoremap <leader>jr :YcmCompleter GoToReferences<CR>
let g:ycm_enable_diagnostic_signs = 0
let g:ycm_show_diagnostics_ui = 0
let g:ycm_autoclose_preview_window_after_insertion = 1

" NERDTree mappings
nnoremap <leader>nc :NERDTreeClose<CR>
nnoremap <leader>nn :NERDTreeMirror<CR>:NERDTreeFind<CR>
nnoremap <leader>no :NERDTree<CR>
" Start NERDTree and put the cursor back in the other window.
" autocmd VimEnter * NERDTree | wincmd p
" Exit Vim if NERDTree is the only window remaining in the only tab.
autocmd BufEnter * if tabpagenr('$') == 1 && winnr('$') == 1 && exists('b:NERDTree') && b:NERDTree.isTabTree() | quit | endif
" Close the tab if NERDTree is the only window remaining in it.
autocmd BufEnter * if winnr('$') == 1 && exists('b:NERDTree') && b:NERDTree.isTabTree() | quit | endif

" Use CSyntaxAfter plugin for syntax highlight on C-like languages
autocmd! FileType c,cpp,java,php call CSyntaxAfter()

" Set highlight at 101th column for informative purposes
" For git commit, highlight the 72th column
let &colorcolumn="101"
autocmd FileType gitcommit let &colorcolumn="72"

" easymotion highlight colors
hi clear EasyMotionShade
hi link EasyMotionShade Comment

" BEGIN ctrlp.vim configs =========================
let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files -co --exclude-standard']
" END ctrlp.vim configs =========================

" Automatically open quickfix after vimgrep
augroup quickfix
    autocmd!
    autocmd QuickFixCmdPost [^1]* cwindow
    autocmd QuickFixCmdPost 1* lwindow
augroup END

" Rename tabs to show tab# and # of viewports
if exists("+showtabline")
    set tabpagemax=15
    hi TabLineSel term=bold cterm=underline,bold ctermfg=16 ctermbg=darkmagenta
    hi TabWinNumSel term=underline cterm=underline,bold ctermfg=90 ctermbg=darkmagenta
    hi TabNumSel term=underline cterm=underline,bold ctermfg=16 ctermbg=darkmagenta

    hi TabLine term=none cterm=none ctermfg=16 ctermbg=145
    hi TabWinNum term=none cterm=none ctermfg=90 ctermbg=145
    hi TabNum term=none cterm=none ctermfg=16 ctermbg=145

    function! MyTabLine()
        let s = ''
        let wn = ''
        let t = tabpagenr()
        let i = 1
        while i <= tabpagenr('$')
            let buflist = tabpagebuflist(i)
            let winnr = tabpagewinnr(i)
            let s .= '%' . i . 'T'
            let s .= (i == t ? '%1*' : '%2*')
            let s .= ' '
            let s .= (i == 1 ? '' : '| ')
            let wn = tabpagewinnr(i,'$')

            let s .= (i== t ? '%#TabNumSel#' : '%#TabNum#')
            let s .= i
            if tabpagewinnr(i,'$') > 1
                let s .= '.'
                let s .= (i== t ? '%#TabWinNumSel#' : '%#TabWinNum#')
                let s .= (tabpagewinnr(i,'$') > 1 ? wn : '')
            end

            let s .= ' %*'
            let s .= (i == t ? '%#TabLineSel#' : '%#TabLine#')
            let bufnr = buflist[winnr - 1]
            let file = bufname(bufnr)
            let buftype = getbufvar(bufnr, 'buftype')
            if buftype == 'nofile'
                if file =~ '\/.'
                    let file = substitute(file, '.*\/\ze.', '', '')
                endif
            else
                let file = fnamemodify(file, ':p:t')
            endif
            if file == ''
                let file = '[No Name]'
            endif
            let s .= file
            "let s .= (i == t ? '%m' : '')
            " Use below line t indicate whether a tab has been modified as it
            " works not only for the current tabs, but for all
            let s .= (getbufvar(buflist[winnr - 1], "&mod") ? '*' : '')
            let i = i + 1
        endwhile
        let s .= '%T%#TabLineFill#%='
        return s
    endfunction
    set stal=2
    set tabline=%!MyTabLine()
endif

" Map F2 to toggle quickfix window
function! ToggleQuickFix()
    if empty(filter(getwininfo(), 'v:val.quickfix'))
        copen
    else
        cclose
    endif
endfunction

nnoremap <silent> <F2> :call ToggleQuickFix()<cr>
